#!/usr/bin/env coco

#### `ckup` command line interface
Ckup = require \ckup
o    = require(\coco/optparse) do
  print   : 'write to stdout instead of .htm'
  stdin   : 'read stdin, then write to the given file or stdout'
  eval    : 'read arguments as source'
  watch   : 'watch and rerender on changes'
  css     : 'render as ccss'
  version : 'show version'
  help    : 'show me'

v() if o.version
h() if o.help

files = o.$args
fs    = require \fs

do ->
  return listen()              if o.stdin
  return render files.join \\n if o.eval
  for file of files
    render fs.readFileSync(file, \utf8), file
    watch file if o.watch
  return if file or o.version or o.help
  h v()
  console.log '\nlistening to stdin...'
  listen()

function render (code, name, asis) ->
  kup = Ckup.render if o.css then '<- -> text css it\n' + code else code
  return console.log \%s kup if not name or o.print
  unless asis
    name.=replace /\.\w+$/ ''
    name += \. + if o.css then \css else
      # Extension for HTML output is fixed for now.
      # __.html__ for _index_, __.htm__ for others.
      if /\/index$/test "/#{name}" then \html else \htm
  fs.writeFileSync name, kup
  (try require \util catch then console)log name

function listen ->
  code  = ''
  stdin = process.openStdin()
  stdin.on \data -> code += it
  stdin.on \end  -> render code, files.0, true

function watch (file) ->
  curr, prev <- fs.watchFile file, {+persistent, interval: 500ms}
  return if curr.size is prev.size and +curr.mtime is +prev.mtime
  try render fs.readFileSync(file, \utf8), file
  catch e then console.error e?.stack or e

function v -> console.log 'ckup ' + Ckup.VERSION
function h -> console.log 'Usage: ckup [options] [files]\n%s' o
